// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.footholdtech.fivetran;

import com.footholdtech.fivetran.ConnectorSchemaConfigArgs;
import com.footholdtech.fivetran.Utilities;
import com.footholdtech.fivetran.inputs.ConnectorSchemaConfigState;
import com.footholdtech.fivetran.outputs.ConnectorSchemaConfigSchema;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## ---
 * 
 * page_title: &#34;Resource: fivetran.ConnectorSchemaConfig&#34;
 * ---
 * 
 * # Resource: fivetran.ConnectorSchemaConfig
 * 
 * This resource allows you to manage the Standard Configuration settings of a connector:
 *  - Define the schema change handling settings
 *  - Enable and disable schemas, tables, and columns
 * 
 * The resource is in **ALPHA** state. The resource schema and behavior are subject to change without prior notice.
 * 
 * Known issues:
 *  - Definition of `sync_mode` for table causes infinite drifting changes in plan
 * 
 * ## Usage guide
 * 
 * Note that all configuration settings are aligned to the `schema_change_handling` settings,  except the settings explicitly specified in `schema`.
 * In `schema`, you only override the default settings defined by the chosen `schema_change_handling` option. The default value for the `enabled` attribute is `true` so it can be omitted when you want to enable schemas, tables, or columns.
 * The allowed `schema_change_handling` options are as follows:
 * - `ALLOW_ALL`- all schemas, tables and columns are ENABLED by default. You only need  to explicitly specify DISABLED items or hashed tables
 * - `BLOCK_ALL` - all schemas, tables and columns are DISABLED by default, the configuration only specifies ENABLED items
 * - `ALLOW_COLUMNS` - all schemas and tables are DISABLED by default, but all columns are ENABLED by default, the configuration specifies ENABLED schemas and tables, and DISABLED columns
 * 
 * Note that system-enabled tables and columns (such as primary and foreign key columns, and [system tables and columns](https://fivetran.com/docs/getting-started/system-columns-and-tables)) are synced regardless of the `schema_change_handling` settings and configuration. You can only disable non-locked columns in the system-enabled tables. If the configuration specifies any system tables or locked system table columns as disabled ( `enabled = &#34;false&#34;`), the provider just ignores these statements.
 * 
 * ## Usage examples
 * 
 * ### Example for the ALLOW_ALL option
 * 
 * In `schema`,  you only need to specify schemas and columns you want to disable (`enabled = &#34;false&#34;`) and tables you want to disable or hash (`hashed = &#34;true&#34;`).
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.fivetran.ConnectorSchemaConfig;
 * import com.pulumi.fivetran.ConnectorSchemaConfigArgs;
 * import com.pulumi.fivetran.inputs.ConnectorSchemaConfigSchemaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var schema = new ConnectorSchemaConfig(&#34;schema&#34;, ConnectorSchemaConfigArgs.builder()        
 *             .connectorId(&#34;connector_id&#34;)
 *             .schemas(            
 *                 ConnectorSchemaConfigSchemaArgs.builder()
 *                     .name(&#34;schema_name&#34;)
 *                     .tables(                    
 *                         ConnectorSchemaConfigSchemaTableArgs.builder()
 *                             .column(                            
 *                                 %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),
 *                                 %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                             .name(&#34;table_name&#34;)
 *                             .build(),
 *                         ConnectorSchemaConfigSchemaTableArgs.builder()
 *                             .enabled(&#34;false&#34;)
 *                             .name(&#34;blocked_table_name&#34;)
 *                             .build())
 *                     .build(),
 *                 ConnectorSchemaConfigSchemaArgs.builder()
 *                     .enabled(&#34;false&#34;)
 *                     .name(&#34;blocked_schema&#34;)
 *                     .build())
 *             .schemaChangeHandling(&#34;ALLOW_ALL&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * The configuration resulting from the example request is as follows:
 * - All new and existing schemas except `blocked_schema` are enabled
 * - All new and existing tables in the `schema_name` schema except the `blocked_table_name` table are enabled
 * - All new and existing columns in the`table_name` of the `schema_name` schema except the `blocked_column_name` column are enabled
 * - The `hashed_column_name` column is hashed in the `table_name` table in the `schema_name` schema
 * - All new schemas, tables, and columns are enabled once captured by the connector during the sync except those disabled by the system
 * 
 * ### Example for the BLOCK_ALL option
 * 
 * All schemas, tables, and columns specified in `schema` are enabled by default (the default value for the `&#34;enabled&#34;` parameter is `true`).
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.fivetran.ConnectorSchemaConfig;
 * import com.pulumi.fivetran.ConnectorSchemaConfigArgs;
 * import com.pulumi.fivetran.inputs.ConnectorSchemaConfigSchemaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var schema = new ConnectorSchemaConfig(&#34;schema&#34;, ConnectorSchemaConfigArgs.builder()        
 *             .connectorId(&#34;connector_id&#34;)
 *             .schemas(            
 *                 ConnectorSchemaConfigSchemaArgs.builder()
 *                     .name(&#34;schema_name&#34;)
 *                     .tables(                    
 *                         ConnectorSchemaConfigSchemaTableArgs.builder()
 *                             .column(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                             .name(&#34;table_name&#34;)
 *                             .build(),
 *                         ConnectorSchemaConfigSchemaTableArgs.builder()
 *                             .name(&#34;enabled_table_name&#34;)
 *                             .build())
 *                     .build(),
 *                 ConnectorSchemaConfigSchemaArgs.builder()
 *                     .name(&#34;enabled_schema_name&#34;)
 *                     .build())
 *             .schemaChangeHandling(&#34;BLOCK_ALL&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * The configuration resulting from the example request is as follows:
 * 
 * - All new and existing schemas except  the `enabled_schema` and `schema_name` are disabled
 * - Only system-enabled tables and columns are enabled in the `enabled_schema_name` schema
 * - All new and existing tables in the `schema_name` schema except  the `enabled_table_name`, `table_name` tables and system tables are disabled
 * - All new and existing columns in the `table_name` table of the `schema_name` schema are disabled except the `hashed_column_name` column and system columns
 * - The `hashed_column_name` column in the `table_name`  table the `schema_name` schema is hashed
 * - All new columns except the system-enabled columns, all schemas and tables are disabled once captured by the connector during the sync
 * 
 * ### Example for the ALLOW_COLUMNS option
 * 
 * In `schema`,  you only need to specify schemas and tables you want to enable `enabled = &#34;true&#34;`) and columns you want to disable (`enabled = &#34;false&#34;`) or hash (`hashed = &#34;true&#34;`).
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.fivetran.ConnectorSchemaConfig;
 * import com.pulumi.fivetran.ConnectorSchemaConfigArgs;
 * import com.pulumi.fivetran.inputs.ConnectorSchemaConfigSchemaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var schema = new ConnectorSchemaConfig(&#34;schema&#34;, ConnectorSchemaConfigArgs.builder()        
 *             .connectorId(&#34;connector_id&#34;)
 *             .schemas(            
 *                 ConnectorSchemaConfigSchemaArgs.builder()
 *                     .name(&#34;schema_name&#34;)
 *                     .tables(                    
 *                         ConnectorSchemaConfigSchemaTableArgs.builder()
 *                             .column(                            
 *                                 %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),
 *                                 %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                             .name(&#34;table_name&#34;)
 *                             .build(),
 *                         ConnectorSchemaConfigSchemaTableArgs.builder()
 *                             .name(&#34;enabled_table_name&#34;)
 *                             .build())
 *                     .build(),
 *                 ConnectorSchemaConfigSchemaArgs.builder()
 *                     .name(&#34;enabled_schema_name&#34;)
 *                     .build())
 *             .schemaChangeHandling(&#34;ALLOW_COLUMNS&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * The configuration resulting from the example request is as follows:
 * 
 * - All specified existing schemas and tables are enabled and all columns inside them are enabled by default, unless `enabled = &#34;false&#34;` is specified for the column
 * - All new and existing schemas except the `enabled_schema_name` and `schema_name` are disabled
 * - Only system-enabled tables and columns would be enabled in  the`enabled_schema_name` schema
 * - All new and existing tables in the `schema_name` schema except the `enabled_table_name`, `table_name` and system-enabled tables are disabled
 * - All new and existing columns in the`table_name` table of the `schema_name` schema except the `disabled_columns_name` and system-enabled columns are enabled
 * - The `hashed_column_name` would be hashed in table `table_name` in schema `schema_name`
 * - All new non system-enabled tables/schemas would be disabled once captured by connector on sync
 * - All new non system-enabled columns inside enabled tables (including system enabled-tables) would be enabled once captured by connector on sync
 * 
 * &lt;a id=&#34;nestedblock--nonlocked&#34;&gt;&lt;/a&gt;
 * ### Non-locked table column management in system-enabled tables
 * 
 * You cannot manage system-enabled tables, but you can manage its non-locked columns. For example, your schema `schema_name` has a system-enabled table `system_enabled_table` that can&#39;t be disabled, and you want to disable one of its columns named `columns_name`:
 * 
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.fivetran.ConnectorSchemaConfig;
 * import com.pulumi.fivetran.ConnectorSchemaConfigArgs;
 * import com.pulumi.fivetran.inputs.ConnectorSchemaConfigSchemaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var schema = new ConnectorSchemaConfig(&#34;schema&#34;, ConnectorSchemaConfigArgs.builder()        
 *             .connectorId(&#34;connector_id&#34;)
 *             .schemas(ConnectorSchemaConfigSchemaArgs.builder()
 *                 .name(&#34;schema_name&#34;)
 *                 .tables(ConnectorSchemaConfigSchemaTableArgs.builder()
 *                     .column(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                     .name(&#34;system_enabled_table&#34;)
 *                     .build())
 *                 .build())
 *             .schemaChangeHandling(&#34;ALLOW_COLUMNS&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * 1. To import an existing `fivetran_connector_schema_config` resource into your Terraform state, you need to get **Fivetran Connector ID** on the **Setup** tab of the connector page in your Fivetran dashboard. 2. Retrieve all connectors in a particular group using the [fivetran_group_connectors data source](/docs/data-sources/group_connectors). To retrieve existing groups, use the [fivetran_groups data source](/docs/data-sources/groups). 3. Define an empty resource in your `.tf` configurationhcl resource &#34;fivetran_connector_schema_config&#34; &#34;my_imported_connector_schema_config&#34; { }
 * 
 * ```sh
 *  $ pulumi import fivetran:index/connectorSchemaConfig:ConnectorSchemaConfig
 * 
 * Run the `terraform import` command
 * ```
 * 
 * ```sh
 *  $ pulumi import fivetran:index/connectorSchemaConfig:ConnectorSchemaConfig my_imported_connector_schema_config {your Fivetran Connector ID}
 * ```
 * 
 * 5.  
 * 
 * Use the `terraform state show` command to get the values from the stateterraform state show &#39;fivetran_connector_schema_config.my_imported_connector_schema_config&#39; 6. Copy the values and paste them to your `.tf` configuration.
 * 
 */
@ResourceType(type="fivetran:index/connectorSchemaConfig:ConnectorSchemaConfig")
public class ConnectorSchemaConfig extends com.pulumi.resources.CustomResource {
    /**
     * The unique identifier for the connector within the Fivetran system.
     * 
     */
    @Export(name="connectorId", refs={String.class}, tree="[0]")
    private Output<String> connectorId;

    /**
     * @return The unique identifier for the connector within the Fivetran system.
     * 
     */
    public Output<String> connectorId() {
        return this.connectorId;
    }
    @Export(name="schemaChangeHandling", refs={String.class}, tree="[0]")
    private Output<String> schemaChangeHandling;

    public Output<String> schemaChangeHandling() {
        return this.schemaChangeHandling;
    }
    @Export(name="schemas", refs={List.class,ConnectorSchemaConfigSchema.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ConnectorSchemaConfigSchema>> schemas;

    public Output<Optional<List<ConnectorSchemaConfigSchema>>> schemas() {
        return Codegen.optional(this.schemas);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ConnectorSchemaConfig(String name) {
        this(name, ConnectorSchemaConfigArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ConnectorSchemaConfig(String name, ConnectorSchemaConfigArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ConnectorSchemaConfig(String name, ConnectorSchemaConfigArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("fivetran:index/connectorSchemaConfig:ConnectorSchemaConfig", name, args == null ? ConnectorSchemaConfigArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private ConnectorSchemaConfig(String name, Output<String> id, @Nullable ConnectorSchemaConfigState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("fivetran:index/connectorSchemaConfig:ConnectorSchemaConfig", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ConnectorSchemaConfig get(String name, Output<String> id, @Nullable ConnectorSchemaConfigState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ConnectorSchemaConfig(name, id, state, options);
    }
}
