// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fivetran

import (
	"context"
	"reflect"

	"errors"
	"github.com/footholdtech/pulumi-fivetran/sdk/go/fivetran/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// -This resource allows you to manage connectors schedule: pause/unpause connector, set dailySyncTime and sync_frequency.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/footholdtech/pulumi-fivetran/sdk/go/fivetran"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := fivetran.NewConnectorSchedule(ctx, "myConnectorSchedule", &fivetran.ConnectorScheduleArgs{
//				ConnectorId:     pulumi.Any(fivetran_connector.My_connector.Id),
//				SyncFrequency:   pulumi.String("1440"),
//				DailySyncTime:   pulumi.String("03:00"),
//				Paused:          pulumi.String("false"),
//				PauseAfterTrial: pulumi.String("true"),
//				ScheduleType:    pulumi.String("auto"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// You don't need to import this resource as it is synthetic.
//
// To fetch schedule values from existing connector use `fivetran_connector` data sourcehcl data "fivetran_connector" "my_connector" {
//
//	id = "my_connector_id" } now you can use schedule values from this data_source:
//
//	sync_frequency = data.fivetran_connector.my_connector.sync_frequency
//
//	paused = data.fivetran_connector.my_connector.paused This resource manages settings for already existing connector instance and doesn't create a new one. If you already have an existing connector with id = `my_connector_id` just define `fivetran_connector_schedule` resourcehcl resource "fivetran_connector_schedule" "my_connector_schedule" {
//
//	connector_id = "my_connector_id"
//
//	sync_frequency
//
//	= "360"
//
//	paused
//
//	= false
//
//	pause_after_trial
//
// = true
//
//	schedule_type
//
// = "auto" } -> NOTEYou can't have several resources managing the same `connector_id`. They will be in conflict ater each `apply`.
type ConnectorSchedule struct {
	pulumi.CustomResourceState

	// The unique identifier for the connector
	ConnectorId pulumi.StringOutput `pulumi:"connectorId"`
	// The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
	DailySyncTime pulumi.StringPtrOutput `pulumi:"dailySyncTime"`
	// Specifies whether the connector should be paused after the free trial period has ended
	PauseAfterTrial pulumi.StringOutput `pulumi:"pauseAfterTrial"`
	// Specifies whether the connector is paused
	Paused pulumi.StringOutput `pulumi:"paused"`
	// The connector schedule configuration type. Supported values: auto, manual
	ScheduleType pulumi.StringOutput `pulumi:"scheduleType"`
	// The connector sync frequency in minutes. Supported values: 1, 5, 15, 30, 60, 120, 180, 360, 480, 720, 1440.
	SyncFrequency pulumi.StringOutput `pulumi:"syncFrequency"`
}

// NewConnectorSchedule registers a new resource with the given unique name, arguments, and options.
func NewConnectorSchedule(ctx *pulumi.Context,
	name string, args *ConnectorScheduleArgs, opts ...pulumi.ResourceOption) (*ConnectorSchedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectorId == nil {
		return nil, errors.New("invalid value for required argument 'ConnectorId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ConnectorSchedule
	err := ctx.RegisterResource("fivetran:index/connectorSchedule:ConnectorSchedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConnectorSchedule gets an existing ConnectorSchedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConnectorSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConnectorScheduleState, opts ...pulumi.ResourceOption) (*ConnectorSchedule, error) {
	var resource ConnectorSchedule
	err := ctx.ReadResource("fivetran:index/connectorSchedule:ConnectorSchedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ConnectorSchedule resources.
type connectorScheduleState struct {
	// The unique identifier for the connector
	ConnectorId *string `pulumi:"connectorId"`
	// The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
	DailySyncTime *string `pulumi:"dailySyncTime"`
	// Specifies whether the connector should be paused after the free trial period has ended
	PauseAfterTrial *string `pulumi:"pauseAfterTrial"`
	// Specifies whether the connector is paused
	Paused *string `pulumi:"paused"`
	// The connector schedule configuration type. Supported values: auto, manual
	ScheduleType *string `pulumi:"scheduleType"`
	// The connector sync frequency in minutes. Supported values: 1, 5, 15, 30, 60, 120, 180, 360, 480, 720, 1440.
	SyncFrequency *string `pulumi:"syncFrequency"`
}

type ConnectorScheduleState struct {
	// The unique identifier for the connector
	ConnectorId pulumi.StringPtrInput
	// The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
	DailySyncTime pulumi.StringPtrInput
	// Specifies whether the connector should be paused after the free trial period has ended
	PauseAfterTrial pulumi.StringPtrInput
	// Specifies whether the connector is paused
	Paused pulumi.StringPtrInput
	// The connector schedule configuration type. Supported values: auto, manual
	ScheduleType pulumi.StringPtrInput
	// The connector sync frequency in minutes. Supported values: 1, 5, 15, 30, 60, 120, 180, 360, 480, 720, 1440.
	SyncFrequency pulumi.StringPtrInput
}

func (ConnectorScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*connectorScheduleState)(nil)).Elem()
}

type connectorScheduleArgs struct {
	// The unique identifier for the connector
	ConnectorId string `pulumi:"connectorId"`
	// The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
	DailySyncTime *string `pulumi:"dailySyncTime"`
	// Specifies whether the connector should be paused after the free trial period has ended
	PauseAfterTrial *string `pulumi:"pauseAfterTrial"`
	// Specifies whether the connector is paused
	Paused *string `pulumi:"paused"`
	// The connector schedule configuration type. Supported values: auto, manual
	ScheduleType *string `pulumi:"scheduleType"`
	// The connector sync frequency in minutes. Supported values: 1, 5, 15, 30, 60, 120, 180, 360, 480, 720, 1440.
	SyncFrequency *string `pulumi:"syncFrequency"`
}

// The set of arguments for constructing a ConnectorSchedule resource.
type ConnectorScheduleArgs struct {
	// The unique identifier for the connector
	ConnectorId pulumi.StringInput
	// The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
	DailySyncTime pulumi.StringPtrInput
	// Specifies whether the connector should be paused after the free trial period has ended
	PauseAfterTrial pulumi.StringPtrInput
	// Specifies whether the connector is paused
	Paused pulumi.StringPtrInput
	// The connector schedule configuration type. Supported values: auto, manual
	ScheduleType pulumi.StringPtrInput
	// The connector sync frequency in minutes. Supported values: 1, 5, 15, 30, 60, 120, 180, 360, 480, 720, 1440.
	SyncFrequency pulumi.StringPtrInput
}

func (ConnectorScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*connectorScheduleArgs)(nil)).Elem()
}

type ConnectorScheduleInput interface {
	pulumi.Input

	ToConnectorScheduleOutput() ConnectorScheduleOutput
	ToConnectorScheduleOutputWithContext(ctx context.Context) ConnectorScheduleOutput
}

func (*ConnectorSchedule) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorSchedule)(nil)).Elem()
}

func (i *ConnectorSchedule) ToConnectorScheduleOutput() ConnectorScheduleOutput {
	return i.ToConnectorScheduleOutputWithContext(context.Background())
}

func (i *ConnectorSchedule) ToConnectorScheduleOutputWithContext(ctx context.Context) ConnectorScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorScheduleOutput)
}

// ConnectorScheduleArrayInput is an input type that accepts ConnectorScheduleArray and ConnectorScheduleArrayOutput values.
// You can construct a concrete instance of `ConnectorScheduleArrayInput` via:
//
//	ConnectorScheduleArray{ ConnectorScheduleArgs{...} }
type ConnectorScheduleArrayInput interface {
	pulumi.Input

	ToConnectorScheduleArrayOutput() ConnectorScheduleArrayOutput
	ToConnectorScheduleArrayOutputWithContext(context.Context) ConnectorScheduleArrayOutput
}

type ConnectorScheduleArray []ConnectorScheduleInput

func (ConnectorScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConnectorSchedule)(nil)).Elem()
}

func (i ConnectorScheduleArray) ToConnectorScheduleArrayOutput() ConnectorScheduleArrayOutput {
	return i.ToConnectorScheduleArrayOutputWithContext(context.Background())
}

func (i ConnectorScheduleArray) ToConnectorScheduleArrayOutputWithContext(ctx context.Context) ConnectorScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorScheduleArrayOutput)
}

// ConnectorScheduleMapInput is an input type that accepts ConnectorScheduleMap and ConnectorScheduleMapOutput values.
// You can construct a concrete instance of `ConnectorScheduleMapInput` via:
//
//	ConnectorScheduleMap{ "key": ConnectorScheduleArgs{...} }
type ConnectorScheduleMapInput interface {
	pulumi.Input

	ToConnectorScheduleMapOutput() ConnectorScheduleMapOutput
	ToConnectorScheduleMapOutputWithContext(context.Context) ConnectorScheduleMapOutput
}

type ConnectorScheduleMap map[string]ConnectorScheduleInput

func (ConnectorScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConnectorSchedule)(nil)).Elem()
}

func (i ConnectorScheduleMap) ToConnectorScheduleMapOutput() ConnectorScheduleMapOutput {
	return i.ToConnectorScheduleMapOutputWithContext(context.Background())
}

func (i ConnectorScheduleMap) ToConnectorScheduleMapOutputWithContext(ctx context.Context) ConnectorScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorScheduleMapOutput)
}

type ConnectorScheduleOutput struct{ *pulumi.OutputState }

func (ConnectorScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorSchedule)(nil)).Elem()
}

func (o ConnectorScheduleOutput) ToConnectorScheduleOutput() ConnectorScheduleOutput {
	return o
}

func (o ConnectorScheduleOutput) ToConnectorScheduleOutputWithContext(ctx context.Context) ConnectorScheduleOutput {
	return o
}

// The unique identifier for the connector
func (o ConnectorScheduleOutput) ConnectorId() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorSchedule) pulumi.StringOutput { return v.ConnectorId }).(pulumi.StringOutput)
}

// The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
func (o ConnectorScheduleOutput) DailySyncTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ConnectorSchedule) pulumi.StringPtrOutput { return v.DailySyncTime }).(pulumi.StringPtrOutput)
}

// Specifies whether the connector should be paused after the free trial period has ended
func (o ConnectorScheduleOutput) PauseAfterTrial() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorSchedule) pulumi.StringOutput { return v.PauseAfterTrial }).(pulumi.StringOutput)
}

// Specifies whether the connector is paused
func (o ConnectorScheduleOutput) Paused() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorSchedule) pulumi.StringOutput { return v.Paused }).(pulumi.StringOutput)
}

// The connector schedule configuration type. Supported values: auto, manual
func (o ConnectorScheduleOutput) ScheduleType() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorSchedule) pulumi.StringOutput { return v.ScheduleType }).(pulumi.StringOutput)
}

// The connector sync frequency in minutes. Supported values: 1, 5, 15, 30, 60, 120, 180, 360, 480, 720, 1440.
func (o ConnectorScheduleOutput) SyncFrequency() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorSchedule) pulumi.StringOutput { return v.SyncFrequency }).(pulumi.StringOutput)
}

type ConnectorScheduleArrayOutput struct{ *pulumi.OutputState }

func (ConnectorScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConnectorSchedule)(nil)).Elem()
}

func (o ConnectorScheduleArrayOutput) ToConnectorScheduleArrayOutput() ConnectorScheduleArrayOutput {
	return o
}

func (o ConnectorScheduleArrayOutput) ToConnectorScheduleArrayOutputWithContext(ctx context.Context) ConnectorScheduleArrayOutput {
	return o
}

func (o ConnectorScheduleArrayOutput) Index(i pulumi.IntInput) ConnectorScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ConnectorSchedule {
		return vs[0].([]*ConnectorSchedule)[vs[1].(int)]
	}).(ConnectorScheduleOutput)
}

type ConnectorScheduleMapOutput struct{ *pulumi.OutputState }

func (ConnectorScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConnectorSchedule)(nil)).Elem()
}

func (o ConnectorScheduleMapOutput) ToConnectorScheduleMapOutput() ConnectorScheduleMapOutput {
	return o
}

func (o ConnectorScheduleMapOutput) ToConnectorScheduleMapOutputWithContext(ctx context.Context) ConnectorScheduleMapOutput {
	return o
}

func (o ConnectorScheduleMapOutput) MapIndex(k pulumi.StringInput) ConnectorScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ConnectorSchedule {
		return vs[0].(map[string]*ConnectorSchedule)[vs[1].(string)]
	}).(ConnectorScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorScheduleInput)(nil)).Elem(), &ConnectorSchedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorScheduleArrayInput)(nil)).Elem(), ConnectorScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorScheduleMapInput)(nil)).Elem(), ConnectorScheduleMap{})
	pulumi.RegisterOutputType(ConnectorScheduleOutput{})
	pulumi.RegisterOutputType(ConnectorScheduleArrayOutput{})
	pulumi.RegisterOutputType(ConnectorScheduleMapOutput{})
}
