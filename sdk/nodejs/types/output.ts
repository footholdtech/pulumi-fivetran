// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ConnectorAuth {
    accessToken?: string;
    awsAccessKey?: string;
    awsSecretKey?: string;
    clientAccess?: outputs.ConnectorAuthClientAccess;
    clientId?: string;
    clientSecret?: string;
    consumerKey?: string;
    consumerSecret?: string;
    keyId?: string;
    oauthToken?: string;
    oauthTokenSecret?: string;
    previousRefreshToken?: string;
    realmId?: string;
    refreshToken?: string;
    roleArn?: string;
    teamId?: string;
    userAccessToken?: string;
}

export interface ConnectorAuthClientAccess {
    clientId?: string;
    clientSecret?: string;
    developerToken?: string;
    userAgent?: string;
}

export interface ConnectorCertificatesCertificate {
    /**
     * Base64 encoded certificate.
     */
    encodedCert: string;
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * Certificate name.
     */
    name: string;
    /**
     * Certificate public key.
     */
    publicKey: string;
    /**
     * Certificate sha1.
     */
    sha1: string;
    /**
     * Certificate sha256.
     */
    sha256: string;
    /**
     * Certificate type.
     */
    type: string;
    /**
     * User name who validated the certificate.
     */
    validatedBy: string;
    /**
     * The date when the certificate was approved.
     */
    validatedDate: string;
}

export interface ConnectorConfig {
    absConnectionMethod?: string;
    absConnectionString: string;
    absContainerAddress?: string;
    absContainerName: string;
    absHostIp?: string;
    absHostUser?: string;
    absPrefix?: string;
    absPublicKey?: string;
    accessKey: string;
    accessKeyId: string;
    accessKeySecret?: string;
    accessToken: string;
    accessType?: string;
    account: string;
    accountId: string;
    accountIds?: string[];
    accountKey: string;
    accountName?: string;
    accountSyncMode?: string;
    accounts?: string[];
    accountsRedditAds?: outputs.ConnectorConfigAccountsRedditAd[];
    accountsSyncMode?: string;
    actionBreakdowns?: string[];
    actionReportTime: string;
    adAnalytics?: string;
    adUnitView?: string;
    adminApiKey?: string;
    adobeAnalyticsConfigurations?: outputs.ConnectorConfigAdobeAnalyticsConfiguration[];
    advertisables?: string[];
    advertisers?: string[];
    advertisersIds?: string[];
    advertisersSyncMode?: string;
    agentHost: string;
    agentOraHome: string;
    agentPassword: string;
    agentPort: string;
    agentPublicCert: string;
    agentUser: string;
    aggregation: string;
    alwaysEncrypted: string;
    apiAccessToken: string;
    apiId?: string;
    apiKey: string;
    apiKeyApiSecret?: string;
    apiKeys?: string[];
    apiQuota: string;
    apiRequestsPerMinute: string;
    apiSecret: string;
    apiSecretKey?: string;
    apiToken: string;
    apiType: string;
    apiUrl: string;
    apiUsage?: string;
    apiUtilizationPercentage?: string;
    apiVersion: string;
    appId?: string;
    appIds?: string[];
    appIdsAppsflyers?: outputs.ConnectorConfigAppIdsAppsflyer[];
    appKey?: string;
    appSpecificPassword?: string;
    appSyncMode: string;
    appendFileOption: string;
    applicationKey?: string;
    apps?: string[];
    archiveLogFormat?: string;
    archiveLogPath?: string;
    archivePattern: string;
    areSoapCredentialsProvided: string;
    asbIp?: string;
    asmOption: string;
    asmOracleHome: string;
    asmPassword: string;
    asmTns: string;
    asmUser: string;
    attributionWindow?: string;
    attributionWindowSize?: string;
    auth: string;
    authMethod?: string;
    authMode: string;
    authType: string;
    authorizationMethod: string;
    awsRegionCode: string;
    baseCurrency?: string;
    baseDomain?: string;
    baseId?: string;
    baseUrl: string;
    bearerToken?: string;
    blobSasUrl?: string;
    breakdowns?: string[];
    bucket: string;
    bucketName: string;
    bucketService: string;
    businessId?: string;
    businessUnitId?: string;
    certificate: string;
    clickAttributionWindow: string;
    client?: string;
    clientCert?: string;
    clientCertKey?: string;
    clientId: string;
    clientKey?: string;
    clientName: string;
    clientSecret: string;
    cloudStorageType: string;
    columns?: string[];
    companyId: string;
    companyKey?: string;
    companyRequestToken?: string;
    companyUuid?: string;
    compression: string;
    configMethod: string;
    configRepositoryUrl?: string;
    configType: string;
    connectingUser?: string;
    connectingUserEmail?: string;
    connectionMethod: string;
    connectionString: string;
    connectionType: string;
    consumerGroup: string;
    consumerKey: string;
    consumerSecret: string;
    containerAddress?: string;
    containerName: string;
    contentOwnerId?: string;
    conversationWebhookUrl?: string;
    conversionDimensions?: string[];
    conversionReportTime: string;
    conversionWindowSize: string;
    csvDefinition: string;
    currency?: string;
    customEventSyncMode?: string;
    customEvents?: string[];
    customFieldIds?: string[];
    customFloodlightVariables?: string[];
    customReports?: outputs.ConnectorConfigCustomReport[];
    customTables?: outputs.ConnectorConfigCustomTable[];
    customerId: string;
    customerListId: string;
    dailyApiCallLimit: string;
    dataAccessMethod: string;
    dataCenter: string;
    dataSetName?: string;
    database: string;
    datasetId: string;
    datasource: string;
    dateGranularity: string;
    delimiter: string;
    dimensionAttributes?: string[];
    dimensions?: string[];
    distributedConnectorClusterSize: string;
    domain: string;
    domainHostName: string;
    domainName: string;
    domainType: string;
    elements?: string[];
    email: string;
    emptyHeader: string;
    enableAllDimensionCombinations: string;
    enableArchiveLogOnly: string;
    enableDataExtensionsSyncing: string;
    enableDistributedConnectorMode: string;
    enableEnrichments: string;
    enableExports: string;
    enableTde: string;
    encodedPublicKey?: string;
    encryptionKey: string;
    endpoint: string;
    engagementAttributionWindow: string;
    enrichedExport?: string;
    entityId: string;
    environment: string;
    escapeChar: string;
    euRegion: string;
    events?: string[];
    exportStorageType: string;
    externalId: string;
    fields?: string[];
    fileType: string;
    filter?: string;
    financeAccountSyncMode: string;
    financeAccounts?: string[];
    folder?: string;
    folderId: string;
    folderPath?: string;
    forecastId?: string;
    ftpHost: string;
    ftpPassword: string;
    ftpPort: string;
    ftpUser: string;
    function: string;
    functionApp: string;
    functionKey: string;
    functionName: string;
    functionTrigger: string;
    gcsBucket: string;
    gcsFolder: string;
    groupName: string;
    hasManagePermissions: string;
    homeFolder: string;
    host: string;
    hostIp?: string;
    hostUser?: string;
    hosts?: string[];
    identity: string;
    includeOcapiEndpoints: string;
    instance: string;
    instanceNumber?: string;
    instanceUrl?: string;
    integrationKey: string;
    isAccountLevelConnector: string;
    isAuth2Enabled: string;
    isCustomApiCredentials: string;
    isExternalActivitiesEndpointSelected: string;
    isFtps: string;
    isKeypair: string;
    isMultiEntityFeatureEnabled: string;
    isNewPackage: string;
    isPrivateKeyEncrypted: string;
    isPrivateLinkRequired: string;
    isPublic: string;
    isSailthruConnectEnabled: string;
    isSecure: string;
    isSingleTableMode: string;
    isVendor: string;
    jsonDeliveryMode?: string;
    key: string;
    keyPassword?: string;
    keyStoreType?: string;
    keystore?: string;
    keystorePassword?: string;
    lastSyncedChangesUtc_: string;
    latestVersion: string;
    limitForApiCallsToExternalActivitiesEndpoint: string;
    lineSeparator?: string;
    listStrategy: string;
    listSyncMode?: string;
    logJournal?: string;
    logJournalSchema?: string;
    login?: string;
    loginPassword: string;
    managerAccounts?: string[];
    merchantId: string;
    messageType: string;
    metrics?: string[];
    namedRange: string;
    namespace?: string;
    networkCode: string;
    nullSequence: string;
    oauthToken: string;
    oauthTokenSecret: string;
    ocapiClientId?: string;
    ocapiClientSecret?: string;
    ocapiCustomObjectTypes?: string;
    ocapiHostname?: string;
    onError: string;
    onPremise: string;
    organization: string;
    organizationId: string;
    organizations?: string[];
    packedModeTables?: string[];
    packingMode?: string;
    pages?: string[];
    partnerCode?: string;
    partners?: string[];
    passphrase: string;
    password: string;
    pat: string;
    patName?: string;
    patSecret?: string;
    path: string;
    pattern: string;
    pdbName: string;
    pemCertificate: string;
    pemPrivateKey?: string;
    perInteractionDimensions?: string[];
    personalAccessToken?: string;
    pgpPassPhrase?: string;
    pgpSecretKey?: string;
    phoneNumber?: string;
    port: string;
    postClickAttributionWindowSize: string;
    prebuiltReport: string;
    prefix: string;
    primaryKeys?: string[];
    privateKey: string;
    profiles?: string[];
    projectCredentials?: outputs.ConnectorConfigProjectCredential[];
    projectId: string;
    projects?: string[];
    properties?: string[];
    publicKey: string;
    publicationName: string;
    queryId: string;
    queryParamValue?: string;
    refreshTokenExpiresAt?: string;
    region: string;
    replicaId: string;
    replicationSlot: string;
    reportConfigurationIds?: string[];
    reportFormatType?: string;
    reportSuites?: string[];
    reportTimezone?: string;
    reportType: string;
    reportUrl: string;
    reports?: outputs.ConnectorConfigReport[];
    reportsLinkedinAds?: string[];
    repositories?: string[];
    resourceToken?: string;
    resourceUrl: string;
    restApiLimit: string;
    rfcLibraryPath?: string;
    role: string;
    roleArn: string;
    rollbackWindowSize: string;
    s3Bucket?: string;
    s3ExportBucket?: string;
    s3ExportFolder?: string;
    s3ExportRoleArn?: string;
    s3RoleArn?: string;
    s3bucket: string;
    s3externalId: string;
    s3folder: string;
    s3path?: string;
    s3roleArn: string;
    salesAccountSyncMode: string;
    salesAccounts?: string[];
    salesforceSecurityToken?: string;
    sandboxAccount?: string;
    sapSchema?: string;
    sapUser: string;
    saslMechanism?: string;
    saslPlainKey?: string;
    saslPlainSecret?: string;
    saslScram256Key?: string;
    saslScram256Secret?: string;
    saslScram512Key?: string;
    saslScram512Secret?: string;
    schemaRegistryCredentialsSource?: string;
    schemaRegistryKey?: string;
    schemaRegistrySecret?: string;
    schemaRegistryUrls?: string[];
    secret: string;
    secretKey: string;
    secrets: string;
    secretsLists?: outputs.ConnectorConfigSecretsList[];
    securityProtocol: string;
    segments?: string[];
    selectedExports?: string[];
    senderId?: string;
    senderPassword?: string;
    serverAddress?: string;
    serverUrl: string;
    servers?: string[];
    serviceAccount?: string;
    serviceAccountEmail?: string;
    serviceAccountKey?: string;
    serviceVersion: string;
    sftpHost: string;
    sftpIsKeyPair: string;
    sftpPassword: string;
    sftpPort: string;
    sftpPublicKey?: string;
    sftpUser: string;
    shareUrl: string;
    sheetId: string;
    shop: string;
    shortCode: string;
    showRecordsWithNoMetrics: string;
    sid: string;
    signerPublicKey?: string;
    siteAddress?: string;
    siteId: string;
    siteName?: string;
    siteUrls?: string[];
    skipAfter: string;
    skipBefore: string;
    soapUri: string;
    socialDataSyncTimeframe?: string;
    source: string;
    storeHash?: string;
    subDomain: string;
    subdomain: string;
    subscriberName?: string;
    subscription?: string;
    supportConnectedAccountsSync: string;
    supportNestedColumns: string;
    surveyIds?: string;
    swipeAttributionWindow: string;
    syncDataLocker: string;
    syncFormat: string;
    syncFormulaFields: string;
    syncMetadata: string;
    syncMethod: string;
    syncMode: string;
    syncMultipleAccounts: string;
    syncPackMode: string;
    syncPullApi: string;
    syncType: string;
    sysnr?: string;
    tableName?: string;
    tdeCertificate?: string;
    tdeCertificateName?: string;
    tdePassword?: string;
    tdePrivateKey?: string;
    teamId?: string;
    technicalAccountId: string;
    templateLabels?: string[];
    tenant?: string;
    tenantId?: string;
    testTableName: string;
    timeZone: string;
    timeframeMonths: string;
    tns: string;
    tokenAuthenticatedContainer?: string;
    tokenAuthenticatedDatabase?: string;
    tokenId?: string;
    tokenKey: string;
    tokenSecret: string;
    tokenSecretKey?: string;
    topics?: string[];
    trustStoreType?: string;
    trustedCert?: string;
    truststore?: string;
    tunnelHost: string;
    tunnelPort: string;
    tunnelUser: string;
    uniqueId: string;
    updateConfigOnEachSync: string;
    updateMethod: string;
    uri: string;
    useApiKeys: string;
    useCustomerBucket: string;
    useOracleRac: string;
    usePgpEncryptionOptions: string;
    useServiceAccount: string;
    useTemplateLabels: string;
    useWebhooks: string;
    useWorkspace: string;
    user: string;
    userId: string;
    userKey: string;
    userName: string;
    userProfiles?: string[];
    username: string;
    viewAttributionWindow: string;
    viewThroughAttributionWindowSize: string;
    webhookEndpoint?: string;
    webhookKey?: string;
    webhookUrl?: string;
    wordPressSiteIdOrWoocommerceDomainName?: string;
    workspaceName?: string;
    workspaceSameAsSource: string;
    workspaceSchema?: string;
    wsCertificate?: string;
}

export interface ConnectorConfigAccountsRedditAd {
    name?: string;
}

export interface ConnectorConfigAdobeAnalyticsConfiguration {
    calculatedMetrics?: string[];
    elements?: string[];
    metrics?: string[];
    reportSuites?: string[];
    segments?: string[];
    syncMode: string;
    table?: string;
}

export interface ConnectorConfigAppIdsAppsflyer {
    appId?: string;
}

export interface ConnectorConfigCustomReport {
    aggregate?: string;
    baseMetricsFields?: string[];
    breakdown?: string;
    breakout?: string;
    conversionsReportIncluded: string;
    customEventsIncluded: string;
    dimension?: string;
    dimensions?: string[];
    eventNames?: string[];
    granularity?: string;
    level?: string;
    metrics?: string[];
    reportFields?: string[];
    reportName?: string;
    reportType?: string;
    segmentation?: string;
    skAdMetricsFields?: string[];
    tableName?: string;
}

export interface ConnectorConfigCustomTable {
    actionBreakdowns?: string[];
    actionReportTime: string;
    aggregation: string;
    breakdowns?: string[];
    clickAttributionWindow: string;
    configType: string;
    fields?: string[];
    level?: string;
    prebuiltReportName: string;
    tableName: string;
    useUnifiedAttributionSetting: string;
    viewAttributionWindow: string;
}

export interface ConnectorConfigProjectCredential {
    apiKey: string;
    project: string;
    secretKey: string;
}

export interface ConnectorConfigReport {
    aggregation?: string;
    attributes?: string[];
    configType: string;
    dimensions?: string[];
    fields?: string[];
    filter: string;
    filterFieldName?: string;
    filterType?: string;
    filterValue?: string;
    metrics?: string[];
    prebuiltReport: string;
    reportType: string;
    rollbackWindow: string;
    searchTypes?: string[];
    segmentIds?: string[];
    segments?: string[];
    table: string;
}

export interface ConnectorConfigSecretsList {
    key: string;
    value: string;
}

export interface ConnectorDestinationSchema {
    name?: string;
    prefix?: string;
    table?: string;
}

export interface ConnectorFingerprintsFingerprint {
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * The SSH public key.
     */
    publicKey: string;
    /**
     * User name who validated the fingerprint.
     */
    validatedBy: string;
    /**
     * The date when SSH fingerprint was approved.
     */
    validatedDate: string;
}

export interface ConnectorSchemaConfigSchema {
    /**
     * The boolean value specifying whether the sync for the schema into the destination is enabled.
     */
    enabled?: string;
    /**
     * The schema name within your destination in accordance with Fivetran conventional rules.
     */
    name: string;
    tables?: outputs.ConnectorSchemaConfigSchemaTable[];
}

export interface ConnectorSchemaConfigSchemaTable {
    columns?: outputs.ConnectorSchemaConfigSchemaTableColumn[];
    /**
     * The boolean value specifying whether the sync for the schema into the destination is enabled.
     */
    enabled?: string;
    /**
     * The schema name within your destination in accordance with Fivetran conventional rules.
     */
    name: string;
    /**
     * This field appears in the response if the connector supports switching sync modes for tables.
     */
    syncMode?: string;
}

export interface ConnectorSchemaConfigSchemaTableColumn {
    /**
     * The boolean value specifying whether the sync for the schema into the destination is enabled.
     */
    enabled?: string;
    /**
     * The boolean value specifying whether a column should be hashed
     */
    hashed?: string;
    /**
     * The schema name within your destination in accordance with Fivetran conventional rules.
     */
    name: string;
}

export interface DbtProjectModel {
    /**
     * The unique identifier for the dbt Model within the Fivetran system.
     */
    id: string;
    /**
     * The dbt Model name.
     */
    modelName: string;
    /**
     * Boolean specifying whether the model is selected for execution.
     */
    scheduled: boolean;
}

export interface DbtProjectProjectConfig {
    /**
     * Folder in Git repo with your dbt project.
     */
    folderPath: string;
    /**
     * Git branch.
     */
    gitBranch: string;
    /**
     * Git remote URL with your dbt project.
     */
    gitRemoteUrl: string;
}

export interface DbtTransformationSchedule {
    /**
     * The set of the days of the week the transformation should be launched on. The following values are supported: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
     */
    daysOfWeeks: string[];
    /**
     * The time interval in minutes between subsequent transformation runs.
     */
    interval: number;
    /**
     * The type of the schedule to run the dbt Transformation on. The following values are supported: INTEGRATED, TIME*OF*DAY, INTERVAL. For INTEGRATED schedule type, interval and time*of*day values are ignored and only the days*of*week parameter values are taken into account (but may be empty or null). For TIME*OF*DAY schedule type, the interval parameter value is ignored and the time*of*day values is taken into account along with days*of*week value. For INTERVAL schedule type, time*of*day value is ignored and the interval parameter value is taken into account along with days*of*week value.
     */
    scheduleType: string;
    /**
     * The time of the day the transformation should be launched at. Supported values are: "00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00", "08:00", "09:00", "10:00", "11:00", "12:00", "13:00", "14:00", "15:00", "16:00", "17:00", "18:00", "19:00", "20:00", "21:00", "22:00", "23:00"
     */
    timeOfDay: string;
}

export interface DestinationCertificatesCertificate {
    /**
     * Base64 encoded certificate.
     */
    encodedCert: string;
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * Certificate name.
     */
    name: string;
    /**
     * Certificate public key.
     */
    publicKey: string;
    /**
     * Certificate sha1.
     */
    sha1: string;
    /**
     * Certificate sha256.
     */
    sha256: string;
    /**
     * Certificate type.
     */
    type: string;
    /**
     * User name who validated the certificate.
     */
    validatedBy: string;
    /**
     * The date when the certificate was approved.
     */
    validatedDate: string;
}

export interface DestinationConfig {
    /**
     * The connector authorization settings. Check possible config formats in [create method](https://www.terraform.io/openapi/reference/v1/operation/create_connector/)
     */
    auth?: string;
    /**
     * Authentication type. Default value: `PASSWORD`.
     */
    authType?: string;
    /**
     * Customer bucket. If specified, your GCS bucket will be used to process the data instead of a Fivetran-managed bucket. The bucket must be present in the same location as the dataset location.
     */
    bucket?: string;
    /**
     * Catalog name
     */
    catalog?: string;
    /**
     * ClientId of your Azure Data Lake Storage
     */
    clientId?: string;
    /**
     * Cluster ID. Must be populated if `connectionType` is set to `SshTunnel` and `authType` is set to `IAM`.
     */
    clusterId?: string;
    /**
     * Cluster region. Must be populated if `connectionType` is set to `SshTunnel` and `authType` is set to `IAM`.
     */
    clusterRegion?: string;
    /**
     * Connection method. Default value: `Directly`.
     */
    connectionType?: string;
    /**
     * Container Name of your Azure Data Lake Storage
     */
    containerName?: string;
    /**
     * Whether to create external tables
     */
    createExternalTables?: string;
    /**
     * Data location. Datasets will reside in this location.
     */
    dataSetLocation?: string;
    /**
     * Database name
     */
    database?: string;
    /**
     * External location to store Delta tables. Default value: `""`  (null). By default, the external tables will reside in the `/{schema}/{table}` path, and if you specify an external location in the `{externalLocation}/{schema}/{table}` path.
     */
    externalLocation?: string;
    /**
     * ARN of the role which you created with different required policy mentioned in our setup guide
     */
    fivetranRoleArn?: string;
    /**
     * Server name
     */
    host?: string;
    /**
     * HTTP path
     */
    httpPath?: string;
    /**
     * Indicates that a private key is encrypted. The default value: `false`. The field can be specified if authentication type is `KEY_PAIR`.
     */
    isPrivateKeyEncrypted: string;
    /**
     * OneLake lakehouse name
     */
    lakehouseName?: string;
    /**
     * In case private key is encrypted, you are required to enter passphrase that was used to encrypt the private key. The field can be specified if authentication type is `KEY_PAIR`.
     */
    passphrase?: string;
    /**
     * Database user password
     */
    password?: string;
    /**
     * Personal access token
     */
    personalAccessToken?: string;
    /**
     * Server port number
     */
    port?: number;
    /**
     * Prefix path of the bucket for which you have configured access policy. It is not required if access has been granted to entire Bucket in the access policy
     */
    prefixPath?: string;
    /**
     * Private access key.  The field should be specified if authentication type is `KEY_PAIR`.
     */
    privateKey?: string;
    /**
     * BigQuery project ID
     */
    projectId?: string;
    /**
     * Public key to grant Fivetran SSH access to git repository.
     */
    publicKey: string;
    /**
     * Region of your AWS S3 bucket
     */
    region?: string;
    /**
     * The group role that you would like to assign this new user to. Supported group roles: ‘Destination Administrator‘, ‘Destination Reviewer‘, ‘Destination Analyst‘, ‘Connector Creator‘, or a custom destination role
     */
    role?: string;
    /**
     * Role ARN with Redshift permissions. Required if authentication type is `IAM`.
     */
    roleArn?: string;
    /**
     * Private key of the customer service account. If specified, your service account will be used to process the data instead of the Fivetran-managed service account.
     */
    secretKey?: string;
    /**
     * Secret Value of your Azure Data Lake Storage
     */
    secretValue?: string;
    /**
     * Server name
     */
    serverHostName?: string;
    /**
     * Storage Account Name of your Azure Data Lake Storage
     */
    storageAccountName?: string;
    /**
     * TenantId of your Azure Data Lake Storage
     */
    tenantId?: string;
    /**
     * SSH server name. Must be populated if `connectionType` is set to `SshTunnel`.
     */
    tunnelHost?: string;
    /**
     * SSH server port name. Must be populated if `connectionType` is set to `SshTunnel`.
     */
    tunnelPort?: string;
    /**
     * SSH user name. Must be populated if `connectionType` is set to `SshTunnel`.
     */
    tunnelUser?: string;
    /**
     * Database user name
     */
    user?: string;
    /**
     * OneLake workspace name
     */
    workspaceName?: string;
}

export interface DestinationFingerprintsFingerprint {
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * The SSH public key.
     */
    publicKey: string;
    /**
     * User name who validated the fingerprint.
     */
    validatedBy: string;
    /**
     * The date when SSH fingerprint was approved.
     */
    validatedDate: string;
}

export interface ExternalLoggingConfig {
    /**
     * API Key
     */
    apiKey?: string;
    /**
     * Channel
     */
    channel?: string;
    /**
     * Enable SSL
     */
    enableSsl?: boolean;
    /**
     * external_id
     */
    externalId?: string;
    /**
     * Server name
     */
    host?: string;
    /**
     * Server name
     */
    hostname?: string;
    /**
     * Log Group Name
     */
    logGroupName?: string;
    /**
     * Port
     */
    port?: number;
    /**
     * Primary Key
     */
    primaryKey?: string;
    /**
     * Region
     */
    region?: string;
    /**
     * Role Arn
     */
    roleArn?: string;
    /**
     * Sub Domain
     */
    subDomain?: string;
    /**
     * Token
     */
    token?: string;
    /**
     * Workspace ID
     */
    workspaceId?: string;
}

export interface GetConnectorCertificatesCertificate {
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * Certificate name.
     */
    name: string;
    /**
     * Certificate public key.
     */
    publicKey: string;
    /**
     * Certificate sha1.
     */
    sha1: string;
    /**
     * Certificate sha256.
     */
    sha256: string;
    /**
     * Certificate type.
     */
    type: string;
    /**
     * User name who validated the certificate.
     */
    validatedBy: string;
    /**
     * The date when the certificate was approved.
     */
    validatedDate: string;
}

export interface GetConnectorConfig {
    absConnectionMethod: string;
    absConnectionString: string;
    absContainerAddress: string;
    absContainerName: string;
    absHostIp: string;
    absHostUser: string;
    absPrefix: string;
    absPublicKey: string;
    accessKey: string;
    accessKeyId: string;
    accessKeySecret: string;
    accessToken: string;
    accessType: string;
    account: string;
    accountId: string;
    accountIds: string[];
    accountKey: string;
    accountName: string;
    accountSyncMode: string;
    accounts: string[];
    accountsRedditAds: outputs.GetConnectorConfigAccountsRedditAd[];
    accountsSyncMode: string;
    actionBreakdowns: string[];
    actionReportTime: string;
    adAnalytics: string;
    adUnitView: string;
    adminApiKey: string;
    adobeAnalyticsConfigurations: outputs.GetConnectorConfigAdobeAnalyticsConfiguration[];
    advertisables: string[];
    advertisers: string[];
    advertisersIds: string[];
    advertisersSyncMode: string;
    agentHost: string;
    agentOraHome: string;
    agentPassword: string;
    agentPort: string;
    agentPublicCert: string;
    agentUser: string;
    aggregation: string;
    alwaysEncrypted: string;
    apiAccessToken: string;
    apiId: string;
    apiKey: string;
    apiKeyApiSecret: string;
    apiKeys: string[];
    apiQuota: string;
    apiRequestsPerMinute: string;
    apiSecret: string;
    apiSecretKey: string;
    apiToken: string;
    apiType: string;
    apiUrl: string;
    apiUsage: string;
    apiUtilizationPercentage: string;
    apiVersion: string;
    appId: string;
    appIds: string[];
    appIdsAppsflyers: outputs.GetConnectorConfigAppIdsAppsflyer[];
    appKey: string;
    appSpecificPassword: string;
    appSyncMode: string;
    appendFileOption: string;
    applicationKey: string;
    apps: string[];
    archiveLogFormat: string;
    archiveLogPath: string;
    archivePattern: string;
    areSoapCredentialsProvided: string;
    asbIp: string;
    asmOption: string;
    asmOracleHome: string;
    asmPassword: string;
    asmTns: string;
    asmUser: string;
    attributionWindow: string;
    attributionWindowSize: string;
    auth: string;
    authMethod: string;
    authMode: string;
    authType: string;
    authorizationMethod: string;
    awsRegionCode: string;
    baseCurrency: string;
    baseDomain: string;
    baseId: string;
    baseUrl: string;
    bearerToken: string;
    blobSasUrl: string;
    breakdowns: string[];
    bucket: string;
    bucketName: string;
    bucketService: string;
    businessId: string;
    businessUnitId: string;
    certificate: string;
    clickAttributionWindow: string;
    client: string;
    clientCert: string;
    clientCertKey: string;
    clientId: string;
    clientKey: string;
    clientName: string;
    clientSecret: string;
    cloudStorageType: string;
    columns: string[];
    companyId: string;
    companyKey: string;
    companyRequestToken: string;
    companyUuid: string;
    compression: string;
    configMethod: string;
    configRepositoryUrl: string;
    configType: string;
    connectingUser: string;
    connectingUserEmail: string;
    connectionMethod: string;
    connectionString: string;
    connectionType: string;
    consumerGroup: string;
    consumerKey: string;
    consumerSecret: string;
    containerAddress: string;
    containerName: string;
    contentOwnerId: string;
    conversationWebhookUrl: string;
    conversionDimensions: string[];
    conversionReportTime: string;
    conversionWindowSize: string;
    csvDefinition: string;
    currency: string;
    customEventSyncMode: string;
    customEvents: string[];
    customFieldIds: string[];
    customFloodlightVariables: string[];
    customReports: outputs.GetConnectorConfigCustomReport[];
    customTables: outputs.GetConnectorConfigCustomTable[];
    customerId: string;
    customerListId: string;
    dailyApiCallLimit: string;
    dataAccessMethod: string;
    dataCenter: string;
    dataSetName: string;
    database: string;
    datasetId: string;
    datasource: string;
    dateGranularity: string;
    delimiter: string;
    dimensionAttributes: string[];
    dimensions: string[];
    distributedConnectorClusterSize: string;
    domain: string;
    domainHostName: string;
    domainName: string;
    domainType: string;
    elements: string[];
    email: string;
    emptyHeader: string;
    enableAllDimensionCombinations: string;
    enableArchiveLogOnly: string;
    enableDataExtensionsSyncing: string;
    enableDistributedConnectorMode: string;
    enableEnrichments: string;
    enableExports: string;
    enableTde: string;
    encodedPublicKey: string;
    encryptionKey: string;
    endpoint: string;
    engagementAttributionWindow: string;
    enrichedExport: string;
    entityId: string;
    environment: string;
    escapeChar: string;
    euRegion: string;
    events: string[];
    exportStorageType: string;
    externalId: string;
    fields: string[];
    fileType: string;
    filter: string;
    financeAccountSyncMode: string;
    financeAccounts: string[];
    folder: string;
    folderId: string;
    folderPath: string;
    forecastId: string;
    ftpHost: string;
    ftpPassword: string;
    ftpPort: string;
    ftpUser: string;
    function: string;
    functionApp: string;
    functionKey: string;
    functionName: string;
    functionTrigger: string;
    gcsBucket: string;
    gcsFolder: string;
    groupName: string;
    hasManagePermissions: string;
    homeFolder: string;
    host: string;
    hostIp: string;
    hostUser: string;
    hosts: string[];
    identity: string;
    includeOcapiEndpoints: string;
    instance: string;
    instanceNumber: string;
    instanceUrl: string;
    integrationKey: string;
    isAccountLevelConnector: string;
    isAuth2Enabled: string;
    isCustomApiCredentials: string;
    isExternalActivitiesEndpointSelected: string;
    isFtps: string;
    isKeypair: string;
    isMultiEntityFeatureEnabled: string;
    isNewPackage: string;
    isPrivateKeyEncrypted: string;
    isPrivateLinkRequired: string;
    isPublic: string;
    isSailthruConnectEnabled: string;
    isSecure: string;
    isSingleTableMode: string;
    isVendor: string;
    jsonDeliveryMode: string;
    key: string;
    keyPassword: string;
    keyStoreType: string;
    keystore: string;
    keystorePassword: string;
    lastSyncedChangesUtc_: string;
    latestVersion: string;
    limitForApiCallsToExternalActivitiesEndpoint: string;
    lineSeparator: string;
    listStrategy: string;
    listSyncMode: string;
    logJournal: string;
    logJournalSchema: string;
    login: string;
    loginPassword: string;
    managerAccounts: string[];
    merchantId: string;
    messageType: string;
    metrics: string[];
    namedRange: string;
    namespace: string;
    networkCode: string;
    nullSequence: string;
    oauthToken: string;
    oauthTokenSecret: string;
    ocapiClientId: string;
    ocapiClientSecret: string;
    ocapiCustomObjectTypes: string;
    ocapiHostname: string;
    onError: string;
    onPremise: string;
    organization: string;
    organizationId: string;
    organizations: string[];
    packedModeTables: string[];
    packingMode: string;
    pages: string[];
    partnerCode: string;
    partners: string[];
    passphrase: string;
    password: string;
    pat: string;
    patName: string;
    patSecret: string;
    path: string;
    pattern: string;
    pdbName: string;
    pemCertificate: string;
    pemPrivateKey: string;
    perInteractionDimensions: string[];
    personalAccessToken: string;
    pgpPassPhrase: string;
    pgpSecretKey: string;
    phoneNumber: string;
    port: string;
    postClickAttributionWindowSize: string;
    prebuiltReport: string;
    prefix: string;
    primaryKeys: string[];
    privateKey: string;
    profiles: string[];
    projectCredentials: outputs.GetConnectorConfigProjectCredential[];
    projectId: string;
    projects: string[];
    properties: string[];
    publicKey: string;
    publicationName: string;
    queryId: string;
    queryParamValue: string;
    refreshTokenExpiresAt: string;
    region: string;
    replicaId: string;
    replicationSlot: string;
    reportConfigurationIds: string[];
    reportFormatType: string;
    reportSuites: string[];
    reportTimezone: string;
    reportType: string;
    reportUrl: string;
    reports: outputs.GetConnectorConfigReport[];
    reportsLinkedinAds: string[];
    repositories: string[];
    resourceToken: string;
    resourceUrl: string;
    restApiLimit: string;
    rfcLibraryPath: string;
    role: string;
    roleArn: string;
    rollbackWindowSize: string;
    s3Bucket: string;
    s3ExportBucket: string;
    s3ExportFolder: string;
    s3ExportRoleArn: string;
    s3RoleArn: string;
    s3bucket: string;
    s3externalId: string;
    s3folder: string;
    s3path: string;
    s3roleArn: string;
    salesAccountSyncMode: string;
    salesAccounts: string[];
    salesforceSecurityToken: string;
    sandboxAccount: string;
    sapSchema: string;
    sapUser: string;
    saslMechanism: string;
    saslPlainKey: string;
    saslPlainSecret: string;
    saslScram256Key: string;
    saslScram256Secret: string;
    saslScram512Key: string;
    saslScram512Secret: string;
    schemaRegistryCredentialsSource: string;
    schemaRegistryKey: string;
    schemaRegistrySecret: string;
    schemaRegistryUrls: string[];
    secret: string;
    secretKey: string;
    secrets: string;
    secretsLists: outputs.GetConnectorConfigSecretsList[];
    securityProtocol: string;
    segments: string[];
    selectedExports: string[];
    senderId: string;
    senderPassword: string;
    serverAddress: string;
    serverUrl: string;
    servers: string[];
    serviceAccount: string;
    serviceAccountEmail: string;
    serviceAccountKey: string;
    serviceVersion: string;
    sftpHost: string;
    sftpIsKeyPair: string;
    sftpPassword: string;
    sftpPort: string;
    sftpPublicKey: string;
    sftpUser: string;
    shareUrl: string;
    sheetId: string;
    shop: string;
    shortCode: string;
    showRecordsWithNoMetrics: string;
    sid: string;
    signerPublicKey: string;
    siteAddress: string;
    siteId: string;
    siteName: string;
    siteUrls: string[];
    skipAfter: string;
    skipBefore: string;
    soapUri: string;
    socialDataSyncTimeframe: string;
    source: string;
    storeHash: string;
    subDomain: string;
    subdomain: string;
    subscriberName: string;
    subscription: string;
    supportConnectedAccountsSync: string;
    supportNestedColumns: string;
    surveyIds: string;
    swipeAttributionWindow: string;
    syncDataLocker: string;
    syncFormat: string;
    syncFormulaFields: string;
    syncMetadata: string;
    syncMethod: string;
    syncMode: string;
    syncMultipleAccounts: string;
    syncPackMode: string;
    syncPullApi: string;
    syncType: string;
    sysnr: string;
    tableName: string;
    tdeCertificate: string;
    tdeCertificateName: string;
    tdePassword: string;
    tdePrivateKey: string;
    teamId: string;
    technicalAccountId: string;
    templateLabels: string[];
    tenant: string;
    tenantId: string;
    testTableName: string;
    timeZone: string;
    timeframeMonths: string;
    tns: string;
    tokenAuthenticatedContainer: string;
    tokenAuthenticatedDatabase: string;
    tokenId: string;
    tokenKey: string;
    tokenSecret: string;
    tokenSecretKey: string;
    topics: string[];
    trustStoreType: string;
    trustedCert: string;
    truststore: string;
    tunnelHost: string;
    tunnelPort: string;
    tunnelUser: string;
    uniqueId: string;
    updateConfigOnEachSync: string;
    updateMethod: string;
    uri: string;
    useApiKeys: string;
    useCustomerBucket: string;
    useOracleRac: string;
    usePgpEncryptionOptions: string;
    useServiceAccount: string;
    useTemplateLabels: string;
    useWebhooks: string;
    useWorkspace: string;
    user: string;
    userId: string;
    userKey: string;
    userName: string;
    userProfiles: string[];
    username: string;
    viewAttributionWindow: string;
    viewThroughAttributionWindowSize: string;
    webhookEndpoint: string;
    webhookKey: string;
    webhookUrl: string;
    wordPressSiteIdOrWoocommerceDomainName: string;
    workspaceName: string;
    workspaceSameAsSource: string;
    workspaceSchema: string;
    wsCertificate: string;
}

export interface GetConnectorConfigAccountsRedditAd {
    name: string;
}

export interface GetConnectorConfigAdobeAnalyticsConfiguration {
    calculatedMetrics: string[];
    elements: string[];
    metrics: string[];
    reportSuites: string[];
    segments: string[];
    syncMode: string;
    table: string;
}

export interface GetConnectorConfigAppIdsAppsflyer {
    appId: string;
}

export interface GetConnectorConfigCustomReport {
    aggregate: string;
    baseMetricsFields: string[];
    breakdown: string;
    breakout: string;
    conversionsReportIncluded: string;
    customEventsIncluded: string;
    dimension: string;
    dimensions: string[];
    eventNames: string[];
    granularity: string;
    level: string;
    metrics: string[];
    reportFields: string[];
    reportName: string;
    reportType: string;
    segmentation: string;
    skAdMetricsFields: string[];
    tableName: string;
}

export interface GetConnectorConfigCustomTable {
    actionBreakdowns: string[];
    actionReportTime: string;
    aggregation: string;
    breakdowns: string[];
    clickAttributionWindow: string;
    configType: string;
    fields: string[];
    level: string;
    prebuiltReportName: string;
    tableName: string;
    useUnifiedAttributionSetting: string;
    viewAttributionWindow: string;
}

export interface GetConnectorConfigProjectCredential {
    apiKey: string;
    project: string;
    secretKey: string;
}

export interface GetConnectorConfigReport {
    aggregation: string;
    attributes: string[];
    configType: string;
    dimensions: string[];
    fields: string[];
    filter: string;
    filterFieldName: string;
    filterType: string;
    filterValue: string;
    metrics: string[];
    prebuiltReport: string;
    reportType: string;
    rollbackWindow: string;
    searchTypes: string[];
    segmentIds: string[];
    segments: string[];
    table: string;
}

export interface GetConnectorConfigSecretsList {
    key: string;
    value: string;
}

export interface GetConnectorDestinationSchema {
    name: string;
    prefix: string;
    table: string;
}

export interface GetConnectorFingerprintsFingerprint {
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * The SSH public key.
     */
    publicKey: string;
    /**
     * User name who validated the fingerprint.
     */
    validatedBy: string;
    /**
     * The date when SSH fingerprint was approved.
     */
    validatedDate: string;
}

export interface GetConnectorStatus {
    isHistoricalSync: string;
    setupState: string;
    syncState: string;
    tasks: outputs.GetConnectorStatusTask[];
    updateState: string;
    warnings: outputs.GetConnectorStatusWarning[];
}

export interface GetConnectorStatusTask {
    code: string;
    message: string;
}

export interface GetConnectorStatusWarning {
    code: string;
    message: string;
}

export interface GetConnectorsMetadataSource {
    /**
     * The description characterizing the purpose of the connector.
     */
    description: string;
    /**
     * The icon resource URL.
     */
    iconUrl: string;
    /**
     * The unique identifier for the connector within the Fivetran system
     */
    id: string;
    /**
     * The link to the connector documentation.
     */
    linkToDocs: string;
    /**
     * The link to the connector ERD (entity–relationship diagram).
     */
    linkToErd: string;
    /**
     * The connector service name within the Fivetran system.
     */
    name: string;
    /**
     * The connector service type within the Fivetran system.
     */
    type: string;
}

export interface GetDbtModelsModel {
    /**
     * The unique identifier for the dbt Model within the Fivetran system.
     */
    id: string;
    /**
     * The dbt Model name.
     */
    modelName: string;
    /**
     * Boolean specifying whether the model is selected for execution.
     */
    scheduled: boolean;
}

export interface GetDbtProjectModel {
    /**
     * The unique identifier for the dbt Model within the Fivetran system.
     */
    id: string;
    /**
     * The dbt Model name.
     */
    modelName: string;
    /**
     * Boolean specifying whether the model is selected for execution.
     */
    scheduled: boolean;
}

export interface GetDbtProjectProjectConfig {
    folderPath: string;
    gitBranch: string;
    gitRemoteUrl: string;
}

export interface GetDbtProjectsProject {
    /**
     * The timestamp of when the project was created in your account.
     */
    createdAt: string;
    /**
     * The unique identifier for the User within the Fivetran system who created the DBT Project.
     */
    createdById: string;
    /**
     * The name of the group within your account related to the project.
     */
    groupId: string;
    /**
     * The unique identifier for the dbt project within the Fivetran system.
     */
    id: string;
}

export interface GetDbtTransformationSchedule {
    daysOfWeeks: string[];
    interval: number;
    scheduleType: string;
    timeOfDay: string;
}

export interface GetDestinationCertificatesCertificate {
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * Certificate name.
     */
    name: string;
    /**
     * Certificate public key.
     */
    publicKey: string;
    /**
     * Certificate sha1.
     */
    sha1: string;
    /**
     * Certificate sha256.
     */
    sha256: string;
    /**
     * Certificate type.
     */
    type: string;
    /**
     * User name who validated the certificate.
     */
    validatedBy: string;
    /**
     * The date when the certificate was approved.
     */
    validatedDate: string;
}

export interface GetDestinationConfig {
    /**
     * The connector authorization settings. Check possible config formats in [create method](https://www.terraform.io/openapi/reference/v1/operation/create_connector/)
     */
    auth?: string;
    /**
     * Authentication type. Default value: `PASSWORD`.
     */
    authType?: string;
    /**
     * Customer bucket. If specified, your GCS bucket will be used to process the data instead of a Fivetran-managed bucket. The bucket must be present in the same location as the dataset location.
     */
    bucket?: string;
    /**
     * Catalog name
     */
    catalog?: string;
    /**
     * ClientId of your Azure Data Lake Storage
     */
    clientId?: string;
    /**
     * Cluster ID. Must be populated if `connectionType` is set to `SshTunnel` and `authType` is set to `IAM`.
     */
    clusterId?: string;
    /**
     * Cluster region. Must be populated if `connectionType` is set to `SshTunnel` and `authType` is set to `IAM`.
     */
    clusterRegion?: string;
    /**
     * Connection method. Default value: `Directly`.
     */
    connectionType?: string;
    /**
     * Container Name of your Azure Data Lake Storage
     */
    containerName?: string;
    /**
     * Whether to create external tables
     */
    createExternalTables?: string;
    /**
     * Data location. Datasets will reside in this location.
     */
    dataSetLocation?: string;
    /**
     * Database name
     */
    database?: string;
    /**
     * External location to store Delta tables. Default value: `""`  (null). By default, the external tables will reside in the `/{schema}/{table}` path, and if you specify an external location in the `{externalLocation}/{schema}/{table}` path.
     */
    externalLocation?: string;
    /**
     * ARN of the role which you created with different required policy mentioned in our setup guide
     */
    fivetranRoleArn?: string;
    /**
     * Server name
     */
    host?: string;
    /**
     * HTTP path
     */
    httpPath?: string;
    /**
     * Indicates that a private key is encrypted. The default value: `false`. The field can be specified if authentication type is `KEY_PAIR`.
     */
    isPrivateKeyEncrypted: string;
    /**
     * OneLake lakehouse name
     */
    lakehouseName?: string;
    /**
     * In case private key is encrypted, you are required to enter passphrase that was used to encrypt the private key. The field can be specified if authentication type is `KEY_PAIR`.
     */
    passphrase?: string;
    /**
     * Database user password
     */
    password?: string;
    /**
     * Personal access token
     */
    personalAccessToken?: string;
    /**
     * Server port number
     */
    port?: number;
    /**
     * Prefix path of the bucket for which you have configured access policy. It is not required if access has been granted to entire Bucket in the access policy
     */
    prefixPath?: string;
    /**
     * Private access key.  The field should be specified if authentication type is `KEY_PAIR`.
     */
    privateKey?: string;
    /**
     * BigQuery project ID
     */
    projectId?: string;
    /**
     * Public key to grant Fivetran SSH access to git repository.
     */
    publicKey: string;
    /**
     * Region of your AWS S3 bucket
     */
    region?: string;
    /**
     * The group role that you would like to assign this new user to. Supported group roles: ‘Destination Administrator‘, ‘Destination Reviewer‘, ‘Destination Analyst‘, ‘Connector Creator‘, or a custom destination role
     */
    role?: string;
    /**
     * Role ARN with Redshift permissions. Required if authentication type is `IAM`.
     */
    roleArn?: string;
    /**
     * Private key of the customer service account. If specified, your service account will be used to process the data instead of the Fivetran-managed service account.
     */
    secretKey?: string;
    /**
     * Secret Value of your Azure Data Lake Storage
     */
    secretValue?: string;
    /**
     * Server name
     */
    serverHostName?: string;
    /**
     * Storage Account Name of your Azure Data Lake Storage
     */
    storageAccountName?: string;
    /**
     * TenantId of your Azure Data Lake Storage
     */
    tenantId?: string;
    /**
     * SSH server name. Must be populated if `connectionType` is set to `SshTunnel`.
     */
    tunnelHost?: string;
    /**
     * SSH server port name. Must be populated if `connectionType` is set to `SshTunnel`.
     */
    tunnelPort?: string;
    /**
     * SSH user name. Must be populated if `connectionType` is set to `SshTunnel`.
     */
    tunnelUser?: string;
    /**
     * Database user name
     */
    user?: string;
    /**
     * OneLake workspace name
     */
    workspaceName?: string;
}

export interface GetDestinationFingerprintsFingerprint {
    /**
     * Hash of the fingerprint.
     */
    hash: string;
    /**
     * The SSH public key.
     */
    publicKey: string;
    /**
     * User name who validated the fingerprint.
     */
    validatedBy: string;
    /**
     * The date when SSH fingerprint was approved.
     */
    validatedDate: string;
}

export interface GetExternalLoggingConfig {
    /**
     * API Key
     */
    apiKey?: string;
    /**
     * Channel
     */
    channel?: string;
    /**
     * Enable SSL
     */
    enableSsl?: boolean;
    /**
     * external_id
     */
    externalId?: string;
    /**
     * Server name
     */
    host?: string;
    /**
     * Server name
     */
    hostname?: string;
    /**
     * Log Group Name
     */
    logGroupName?: string;
    /**
     * Port
     */
    port?: number;
    /**
     * Primary Key
     */
    primaryKey?: string;
    /**
     * Region
     */
    region?: string;
    /**
     * Role Arn
     */
    roleArn?: string;
    /**
     * Sub Domain
     */
    subDomain?: string;
    /**
     * Token
     */
    token?: string;
    /**
     * Workspace ID
     */
    workspaceId?: string;
}

export interface GetGroupConnectorsConnector {
    /**
     * The unique identifier of the user who has created the connector in your account
     */
    connectedBy: string;
    /**
     * The timestamp of the time the connector was created in your account
     */
    createdAt: string;
    /**
     * The optional parameter that defines the sync start time when the sync frequency is already set or being set by the current request to 1440. It can be specified in one hour increments starting from 00:00 to 23:00. If not specified, we will use [the baseline sync start time](https://fivetran.com/docs/getting-started/syncoverview#syncfrequencyandscheduling). This parameter has no effect on the [0 to 60 minutes offset](https://fivetran.com/docs/getting-started/syncoverview#syncstarttimesandoffsets) used to determine the actual sync start time
     */
    dailySyncTime: string;
    /**
     * The timestamp of the time the connector sync failed last time
     */
    failedAt: string;
    /**
     * The unique identifier for the Group within the Fivetran system.
     */
    groupId: string;
    /**
     * The unique identifier for the Connector within the Fivetran system.
     */
    id: string;
    /**
     * The connector schedule configuration type. Supported values: auto, manual
     */
    scheduleType: string;
    /**
     * The name used both as the connector's name within the Fivetran system and as the source schema's name within your destination
     */
    schema: string;
    /**
     * The connector type name within the Fivetran system
     */
    service: string;
    /**
     * The connector type version within the Fivetran system
     */
    serviceVersion: number;
    statuses: outputs.GetGroupConnectorsConnectorStatus[];
    /**
     * The timestamp of the time the connector sync succeeded last time
     */
    succeededAt: string;
    /**
     * The connector sync frequency in minutes
     */
    syncFrequency: number;
}

export interface GetGroupConnectorsConnectorStatus {
    /**
     * The boolean specifying whether the connector should be triggered to re-sync all historical data. If you set this parameter to TRUE, the next scheduled sync will be historical. If the value is FALSE or not specified, the connector will not re-sync historical data. NOTE: When the value is TRUE, only the next scheduled sync will be historical, all subsequent ones will be incremental. This parameter is set to FALSE once the historical sync is completed.
     */
    isHistoricalSync: boolean;
    /**
     * The current setup state of the connector. The available values are: \n\n - incomplete - the setup config is incomplete, the setup tests never succeeded \n\n - connected - the connector is properly set up \n\n - broken - the connector setup config is broken.
     */
    setupState: string;
    /**
     * The current sync state of the connector. The available values are: \n\n - scheduled - the sync is waiting to be run \n\n - syncing - the sync is currently running \n\n - paused - the sync is currently paused \n\n - rescheduled - the sync is waiting until more API calls are available in the source service.
     */
    syncState: string;
    /**
     * The collection of tasks for the connector
     */
    tasks: outputs.GetGroupConnectorsConnectorStatusTask[];
    /**
     * The current data update state of the connector. The available values are: \n\n - onSchedule - the sync is running smoothly, no delays \n\n - delayed - the data is delayed for a longer time than expected for the update.
     */
    updateState: string;
    warnings: outputs.GetGroupConnectorsConnectorStatusWarning[];
}

export interface GetGroupConnectorsConnectorStatusTask {
    /**
     * Response status code
     */
    code: string;
    /**
     * Response status text
     */
    message: string;
}

export interface GetGroupConnectorsConnectorStatusWarning {
    /**
     * Response status code
     */
    code: string;
    /**
     * Response status text
     */
    message: string;
}

export interface GetGroupUsersUser {
    /**
     * The timestamp that the user created their Fivetran account
     */
    createdAt: string;
    /**
     * The email address that the user has associated with their user profile.
     */
    email: string;
    /**
     * The last name of the user.
     */
    familyName: string;
    /**
     * The first name of the user.
     */
    givenName: string;
    /**
     * The unique identifier for the user within the account.
     */
    id: string;
    /**
     * The field indicates whether the user has verified their email address in the account creation process.
     */
    invited: boolean;
    /**
     * The last time that the user has logged into their Fivetran account.
     */
    loggedInAt: string;
    /**
     * The phone number of the user.
     */
    phone: string;
    /**
     * The user's avatar as a URL link (for example, 'http://mycompany.com/avatars/john_white.png') or base64 data URI (for example, 'data:image/png;base64,aHR0cDovL215Y29tcGFueS5jb20vYXZhdGFycy9qb2huX3doaXRlLnBuZw==')
     */
    picture: string;
    /**
     * The group role that you would like to assign this new user to. Supported group roles: ‘Destination Administrator‘, ‘Destination Reviewer‘, ‘Destination Analyst‘, ‘Connector Creator‘, or a custom destination role
     */
    role: string;
    /**
     * The field indicates whether the user has verified their email address in the account creation process.
     */
    verified: boolean;
}

export interface GetGroupsGroup {
    /**
     * The timestamp of when the group was created in your account.
     */
    createdAt: string;
    /**
     * The unique identifier for the group within the Fivetran system.
     */
    id: string;
    /**
     * The name of the group within your account.
     */
    name: string;
}

export interface GetMetadataColumnsMetadataColumn {
    /**
     * The unique column identifier
     */
    id: string;
    /**
     * The boolean specifying whether the column is a foreign key
     */
    isForeignKey: boolean;
    /**
     * The boolean specifying whether the column is a primary key
     */
    isPrimaryKey: boolean;
    /**
     * The column name in the destination
     */
    nameInDestination: string;
    /**
     * The column name in the source
     */
    nameInSource: string;
    /**
     * The unique identifier of the table associated with the column
     */
    parentId: string;
    /**
     * The column type in the destination
     */
    typeInDestination: string;
    /**
     * The column type in the source
     */
    typeInSource: string;
}

export interface GetMetadataSchemasMetadataSchema {
    /**
     * The unique schema identifier
     */
    id: string;
    /**
     * The schema name in the destination
     */
    nameInDestination: string;
    /**
     * The schema name in the source
     */
    nameInSource: string;
}

export interface GetMetadataTablesMetadataTable {
    /**
     * The unique table identifier
     */
    id: string;
    /**
     * The table name in the destination
     */
    nameInDestination: string;
    /**
     * The table name in the source
     */
    nameInSource: string;
    /**
     * The unique identifier of the schema associated with the table
     */
    parentId: string;
}

export interface GetRolesRole {
    /**
     * The role description
     */
    description: string;
    /**
     * TypeBool
     */
    isCustom: boolean;
    /**
     * The role name
     */
    name: string;
    /**
     * Defines the list of resources the role manages. Supported values: ACCOUNT, DESTINATION, CONNECTOR, and TEAM
     */
    scopes: string[];
}

export interface GetTeamConnectorMembershipsConnector {
    /**
     * The connector unique identifier
     */
    connectorId: string;
    /**
     * The date and time the membership was created
     */
    createdAt: string;
    /**
     * The team's role that links the team and the connector
     */
    role: string;
}

export interface GetTeamGroupMembershipsGroup {
    /**
     * The date and time the membership was created
     */
    createdAt: string;
    /**
     * The group unique identifier
     */
    groupId: string;
    /**
     * The team's role that links the team and the group
     */
    role: string;
}

export interface GetTeamUserMembershipsUser {
    /**
     * The team's role that links the team and the user
     */
    role: string;
    /**
     * The user unique identifier
     */
    userId: string;
}

export interface GetTeamsTeam {
    /**
     * The description of the team within your account.
     */
    description: string;
    /**
     * The unique identifier for the team within your account.
     */
    id: string;
    /**
     * The name of the team within your account.
     */
    name: string;
    /**
     * The account role of the team.
     */
    role: string;
}

export interface GetUsersUser {
    /**
     * The timestamp that the user created their Fivetran account
     */
    createdAt: string;
    /**
     * The email address that the user has associated with their user profile.
     */
    email: string;
    /**
     * The last name of the user.
     */
    familyName: string;
    /**
     * The first name of the user.
     */
    givenName: string;
    /**
     * The unique identifier for the user within the Fivetran system.
     */
    id: string;
    /**
     * The field indicates whether the user has been invited to your account.
     */
    invited: boolean;
    /**
     * The last time that the user has logged into their Fivetran account.
     */
    loggedInAt: string;
    /**
     * The phone number of the user.
     */
    phone: string;
    /**
     * The user's avatar as a URL link (for example, 'http://mycompany.com/avatars/john_white.png') or base64 data URI (for example, 'data:image/png;base64,aHR0cDovL215Y29tcGFueS5jb20vYXZhdGFycy9qb2huX3doaXRlLnBuZw==')
     */
    picture: string;
    /**
     * The field indicates whether the user has verified their email address in the account creation process.
     */
    verified: boolean;
}

export interface GetWebhooksWebhook {
    /**
     * Boolean, if set to true, webhooks are immediately sent in response to events
     */
    active: boolean;
    /**
     * The webhook creation timestamp
     */
    createdAt: string;
    /**
     * The ID of the user who created the webhook.
     */
    createdBy: string;
    /**
     * The array of event types
     */
    events: string[];
    /**
     * The group ID
     */
    groupId: string;
    /**
     * The webhook ID
     */
    id: string;
    /**
     * Specifies whether the setup tests should be run
     */
    runTests?: boolean;
    /**
     * The secret string used for payload signing and masked in the response.
     */
    secret: string;
    /**
     * The webhook type (group, account)
     */
    type: string;
    /**
     * Your webhooks URL endpoint for your application
     */
    url: string;
}

export interface GroupUsersUser {
    /**
     * The email address that the user has associated with their user profile.
     */
    email: string;
    /**
     * The unique identifier for the user within the account.
     */
    id: string;
    /**
     * The group role that you would like to assign this new user to. Supported group roles: ‘Destination Administrator‘, ‘Destination Reviewer‘, ‘Destination Analyst‘, ‘Connector Creator‘, or a custom destination role
     */
    role: string;
}

export interface TeamConnectorMembershipConnector {
    /**
     * The connector unique identifier
     */
    connectorId: string;
    /**
     * The date and time the membership was created
     */
    createdAt: string;
    /**
     * The team's role that links the team and the connector
     */
    role: string;
}

export interface TeamGroupMembershipGroup {
    /**
     * The date and time the membership was created
     */
    createdAt: string;
    /**
     * The group unique identifier
     */
    groupId: string;
    /**
     * The team's role that links the team and the group
     */
    role: string;
}

export interface TeamUserMembershipUser {
    /**
     * The team's role that links the team and the user
     */
    role: string;
    /**
     * The user unique identifier
     */
    userId: string;
}

